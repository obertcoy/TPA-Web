package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/obertcoy/tpa-web/graph"
	"github.com/obertcoy/tpa-web/graph/model"
	"github.com/obertcoy/tpa-web/graph/service"
	"gorm.io/gorm"
)

// User is the resolver for the user field.
func (r *chatResolver) User(ctx context.Context, obj *model.Chat) (*model.User, error) {
	return obj.User, nil
}

// Post is the resolver for the post field.
func (r *chatResolver) Post(ctx context.Context, obj *model.Chat) (*model.Post, error) {
	if obj.PostID == nil {
		return nil, nil
	}
	return obj.Post, nil
}

// User is the resolver for the user field.
func (r *chatRoomResolver) User(ctx context.Context, obj *model.ChatRoom) ([]*model.User, error) {
	return obj.User, nil
}

// Chat is the resolver for the chat field.
func (r *chatRoomResolver) Chat(ctx context.Context, obj *model.ChatRoom) ([]*model.Chat, error) {
	return obj.Chat, nil
}

// Group is the resolver for the group field.
func (r *chatRoomResolver) Group(ctx context.Context, obj *model.ChatRoom) (*model.Group, error) {
	return obj.Group, nil
}

// CreateChatRoom is the resolver for the createChatRoom field.
func (r *mutationResolver) CreateChatRoom(ctx context.Context, inputChatRoom model.NewChatRoom) (*model.ChatRoom, error) {
	var users []*model.User
	var groupID *string = nil

	for _, userID := range inputChatRoom.UserID {
		user, err := service.GetUser(ctx, userID)
		if err != nil {
			return nil, err
		}
		users = append(users, user)
	}

	if inputChatRoom.GroupID != nil {
		groupID = inputChatRoom.GroupID
	}

	room := &model.ChatRoom{
		ID:        uuid.NewString(),
		User:      users,
		CreatedAt: time.Now(),
		GroupID:   groupID,
	}

	if err := r.Database.Create(&room).Error; err != nil {
		return nil, err
	}

	return room, nil
}

// GoToChatRoom is the resolver for the goToChatRoom field.
func (r *mutationResolver) GoToChatRoom(ctx context.Context, inputChatRoom model.NewChatRoom) (*model.ChatRoom, error) {
	room, err := service.GetChatRoomByUser(ctx, inputChatRoom.UserID, inputChatRoom.GroupID)

	if err != nil {
		room, err = r.CreateChatRoom(ctx, inputChatRoom)

		if err != nil {
			return nil, err
		}

		return room, nil
	}

	return room, nil
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, inputChat model.NewChat) (*model.Chat, error) {
	userID := ctx.Value("TokenHeader").(string)

	// userID := "cbda7fec-145f-4cf8-a9f0-442ec7efcd0f"

	chat := &model.Chat{
		ID:         uuid.NewString(),
		Text:       inputChat.Text,
		FileURL:    inputChat.FileURL,
		PostID:     inputChat.PostID,
		UserID:     userID,
		ChatRoomID: inputChat.ChatRoomID,
		CreatedAt:  time.Now(),
	}

	err := r.Database.Save(&chat).Error
	if err != nil {
		return nil, err
	}

	chats, err := service.GetChat(ctx, inputChat.ChatRoomID)

	if err != nil {
		return nil, err
	}

	go func() {
		userChannels, ok := r.ChatRoomChannel[inputChat.ChatRoomID]
		if !ok {
			return
		}
		for userID, _ := range userChannels {
			r.ChatRoomChannel[inputChat.ChatRoomID][userID] <- chats
		}
	}()

	return chat, nil
}

// GetAllChatRoom is the resolver for the getAllChatRoom field.
func (r *queryResolver) GetAllChatRoom(ctx context.Context) ([]*model.ChatRoom, error) {
	userID := ctx.Value("TokenHeader").(string)
	// userID := "cbda7fec-145f-4cf8-a9f0-442ec7efcd0f"
	var room []*model.ChatRoom
	subquery := r.Database.Table("chatroom_users").Select("chat_room_id").Where("user_id = ?", userID)
	return room, r.Database.Debug().Where("id IN (?)", subquery).Preload("Chat", func(db *gorm.DB) *gorm.DB {
		return db.Order("created_at DESC").Preload("User").Preload("Post").Preload("Post.Comment", func(db *gorm.DB) *gorm.DB {
			return db.Order("created_at DESC")
		}).
			Preload("Post.User").
			Preload("Post.Comment.LikedBy").
			Preload("Post.Comment.Replies").
			Preload("Post.LikedBy").
			Preload("Post.SharedBy").
			Preload("Post.Tagged").
			Preload("Post.Group").Limit(1)
	}).Preload("User").Preload("Group").Find(&room).Error
}

// GetChatRoom is the resolver for the getChatRoom field.
func (r *queryResolver) GetChatRoom(ctx context.Context, chatRoomID string) (*model.ChatRoom, error) {
	return service.GetChatRoom(ctx, chatRoomID)
}

// GetChat is the resolver for the getChat field.
func (r *subscriptionResolver) GetChat(ctx context.Context, chatRoomID string) (<-chan []*model.Chat, error) {
	userID := ctx.Value("TokenHeader").(string)
	// userID := "cbda7fec-145f-4cf8-a9f0-442ec7efcd0f"

	if r.ChatRoomChannel == nil {
		r.ChatRoomChannel = make(map[string]map[string]chan []*model.Chat)
	}
	if r.ChatRoomChannel[chatRoomID] == nil {
		r.ChatRoomChannel[chatRoomID] = make(map[string]chan []*model.Chat)
	}
	if r.ChatRoomChannel[chatRoomID][userID] == nil {
		r.ChatRoomChannel[chatRoomID][userID] = make(chan []*model.Chat)
	}

	chats, err := service.GetChat(ctx, chatRoomID)
	fmt.Println(chats)
	if err != nil {
		close(r.ChatRoomChannel[chatRoomID][userID])
	}

	go func() {

		r.ChatRoomChannel[chatRoomID][userID] <- chats

		for {
			select {
			case <-ctx.Done():
				delete(r.ChatRoomChannel[chatRoomID], userID)
				return
			}
		}
	}()

	return r.ChatRoomChannel[chatRoomID][userID], nil
}

// Chat returns graph.ChatResolver implementation.
func (r *Resolver) Chat() graph.ChatResolver { return &chatResolver{r} }

// ChatRoom returns graph.ChatRoomResolver implementation.
func (r *Resolver) ChatRoom() graph.ChatRoomResolver { return &chatRoomResolver{r} }

// Subscription returns graph.SubscriptionResolver implementation.
func (r *Resolver) Subscription() graph.SubscriptionResolver { return &subscriptionResolver{r} }

type chatResolver struct{ *Resolver }
type chatRoomResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
